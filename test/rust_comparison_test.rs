//! Rust test program to compare ta-rust results with TA-Lib reference data
//! 
//! This program loads reference data generated by Python/TA-Lib and compares
//! it with ta-rust function outputs to ensure 100% compatibility.

use ta_rust::prelude::*;
use serde::{Deserialize, Serialize};
use std::fs;
use std::collections::HashMap;

#[derive(Debug, Deserialize)]
struct ReferenceData {
    test_data: TestData,
    talib_results: HashMap<String, Vec<Option<f64>>>,
}

#[derive(Debug, Deserialize)]
struct TestData {
    close: Vec<f64>,
    high: Vec<f64>,
    low: Vec<f64>,
    volume: Vec<f64>,
}

#[derive(Debug, Clone, Serialize)]
struct TestResult {
    function_name: String,
    phase: u8,
    category: String,
    passed: bool,
    max_error: f64,
    mean_error: f64,
    error_message: Option<String>,
}

#[derive(Debug, Serialize)]
struct TestReport {
    total_tests: usize,
    passed_tests: usize,
    failed_tests: usize,
    success_rate: f64,
    tolerance: f64,
    results: Vec<TestResult>,
}

struct TAComparison {
    tolerance: f64,
    reference_data: ReferenceData,
    results: Vec<TestResult>,
}

impl TAComparison {
    fn new(tolerance: f64) -> Result<Self, Box<dyn std::error::Error>> {
        let data = fs::read_to_string("test/talib_reference_data.json")?;
        let reference_data: ReferenceData = serde_json::from_str(&data)?;
        
        Ok(Self {
            tolerance,
            reference_data,
            results: Vec::new(),
        })
    }
    
    fn compare_arrays(&self, talib_result: &[Option<f64>], rust_result: &[f64], _name: &str) 
        -> (bool, f64, f64, Option<String>) {
        
        if talib_result.len() != rust_result.len() {
            return (false, f64::INFINITY, f64::INFINITY, 
                   Some(format!("Length mismatch: {} vs {}", talib_result.len(), rust_result.len())));
        }
        
        let mut valid_errors = Vec::new();
        let mut nan_mismatch = false;
        
        for (_i, (talib_opt, &rust_val)) in talib_result.iter().zip(rust_result.iter()).enumerate() {
            let talib_is_nan = talib_opt.is_none() || talib_opt.unwrap().is_nan();
            let rust_is_nan = rust_val.is_nan();
            
            if talib_is_nan != rust_is_nan {
                nan_mismatch = true;
                break;
            }
            
            if !talib_is_nan && !rust_is_nan {
                let talib_val = talib_opt.unwrap();
                valid_errors.push((talib_val - rust_val).abs());
            }
        }
        
        if nan_mismatch {
            return (false, f64::INFINITY, f64::INFINITY, 
                   Some("NaN patterns don't match".to_string()));
        }
        
        if valid_errors.is_empty() {
            return (true, 0.0, 0.0, None); // All NaN is OK
        }
        
        let max_error = valid_errors.iter().fold(0.0f64, |a, &b| a.max(b));
        let mean_error = valid_errors.iter().sum::<f64>() / valid_errors.len() as f64;
        
        let passed = max_error <= self.tolerance;
        let error_msg = if passed {
            None
        } else {
            Some(format!("Max error {:.2e} > tolerance {:.2e}", max_error, self.tolerance))
        };
        
        (passed, max_error, mean_error, error_msg)
    }
    
    fn test_function(&mut self, func_name: &str, phase: u8, category: &str, 
                    rust_result: Result<Vec<f64>, TAError>) {
        
        let talib_key = func_name;
        let talib_result = match self.reference_data.talib_results.get(talib_key) {
            Some(result) => result,
            None => {
                self.results.push(TestResult {
                    function_name: func_name.to_string(),
                    phase,
                    category: category.to_string(),
                    passed: false,
                    max_error: f64::INFINITY,
                    mean_error: f64::INFINITY,
                    error_message: Some("No TA-Lib reference data found".to_string()),
                });
                return;
            }
        };
        
        match rust_result {
            Ok(rust_values) => {
                let (passed, max_error, mean_error, error_msg) = 
                    self.compare_arrays(&talib_result, &rust_values, func_name);
                
                if passed {
                    println!("‚úÖ {}: Max error {:.2e}", func_name, max_error);
                } else {
                    if let Some(ref msg) = error_msg {
                        println!("‚ùå {}: {}", func_name, msg);
                    } else {
                        println!("‚ùå {}: Unknown error", func_name);
                    }
                }
                
                self.results.push(TestResult {
                    function_name: func_name.to_string(),
                    phase,
                    category: category.to_string(),
                    passed,
                    max_error,
                    mean_error,
                    error_message: error_msg,
                });
            }
            Err(e) => {
                self.results.push(TestResult {
                    function_name: func_name.to_string(),
                    phase,
                    category: category.to_string(),
                    passed: false,
                    max_error: f64::INFINITY,
                    mean_error: f64::INFINITY,
                    error_message: Some(format!("Rust function error: {}", e)),
                });
                println!("‚ùå {}: Rust function error: {}", func_name, e);
            }
        }
    }
    
    fn test_overlap_functions(&mut self) {
        println!("\nüîç Testing Phase 2: Overlap Studies");
        
        let close = self.reference_data.test_data.close.clone();
        
        // Test SMA
        let sma_result = sma(&close, 14);
        self.test_function("sma_14", 2, "Overlap Studies", sma_result);
        
        // Test EMA
        let ema_result = ema(&close, 14);
        self.test_function("ema_14", 2, "Overlap Studies", ema_result);
        
        // Test WMA
        let wma_result = wma(&close, 14);
        self.test_function("wma_14", 2, "Overlap Studies", wma_result);
    }
    
    fn test_momentum_functions(&mut self) {
        println!("\nüîç Testing Phase 3-4: Momentum Indicators");
        
        let close = self.reference_data.test_data.close.clone();
        
        // Test RSI
        let rsi_result = rsi(&close, 14);
        self.test_function("rsi_14", 3, "Momentum", rsi_result);
        
        // Test ROC
        let roc_result = roc(&close, 10);
        self.test_function("roc_10", 3, "Momentum", roc_result);
        
        // Test MOM
        let mom_result = mom(&close, 10);
        self.test_function("mom_10", 3, "Momentum", mom_result);
        
        // Test MACD (only test the main line for now)
        match macd(&close, 12, 26, 9) {
            Ok((macd_line, _signal_line, _histogram)) => {
                self.test_function("macd_line", 4, "Momentum", Ok(macd_line));
            }
            Err(e) => {
                self.test_function("macd_line", 4, "Momentum", Err(e));
            }
        }
    }
    
    fn test_volatility_functions(&mut self) {
        println!("\nüîç Testing Phase 3: Volatility Indicators");
        
        let high = self.reference_data.test_data.high.clone();
        let low = self.reference_data.test_data.low.clone();
        let close = self.reference_data.test_data.close.clone();
        
        // Test ATR
        let atr_result = atr(&high, &low, &close, 14);
        self.test_function("atr_14", 3, "Volatility", atr_result);
        
        // Test NATR
        let natr_result = natr(&high, &low, &close, 14);
        self.test_function("natr_14", 3, "Volatility", natr_result);
        
        // Test TRANGE
        let trange_result = trange(&high, &low, &close);
        self.test_function("trange", 3, "Volatility", trange_result);
    }
    
    fn test_volume_functions(&mut self) {
        println!("\nüîç Testing Phase 5: Volume Indicators");
        
        let close = self.reference_data.test_data.close.clone();
        let volume = self.reference_data.test_data.volume.clone();
        let high = self.reference_data.test_data.high.clone();
        let low = self.reference_data.test_data.low.clone();
        
        // Test OBV
        let obv_result = obv(&close, &volume);
        self.test_function("obv", 5, "Volume", obv_result);
        
        // Test AD
        let ad_result = ad(&high, &low, &close, &volume);
        self.test_function("ad", 5, "Volume", ad_result);
    }
    
    fn test_advanced_overlap_functions(&mut self) {
        println!("\nüîç Testing Phase 5: Advanced Overlap Studies");
        
        let close = self.reference_data.test_data.close.clone();
        let high = self.reference_data.test_data.high.clone();
        let low = self.reference_data.test_data.low.clone();
        
        // Test Bollinger Bands (test middle band)
        match bbands(&close, 20, 2.0) {
            Ok(bb_result) => {
                self.test_function("bbands_middle", 5, "Advanced Overlap", Ok(bb_result.middle));
            }
            Err(e) => {
                self.test_function("bbands_middle", 5, "Advanced Overlap", Err(e));
            }
        }
        
        // Test Parabolic SAR
        let sar_result = sar(&high, &low, 0.02, 0.20);
        self.test_function("sar", 5, "Advanced Overlap", sar_result);
    }
    
    fn run_all_tests(&mut self) {
        println!("üöÄ Starting TA-Rust vs TA-Lib Compatibility Tests");
        println!("üìä Tolerance: {:.2e}", self.tolerance);
        
        self.test_overlap_functions();
        self.test_momentum_functions();
        self.test_volatility_functions();
        self.test_volume_functions();
        self.test_advanced_overlap_functions();
    }
    
    fn generate_report(&self) -> TestReport {
        let total_tests = self.results.len();
        let passed_tests = self.results.iter().filter(|r| r.passed).count();
        let failed_tests = total_tests - passed_tests;
        let success_rate = if total_tests > 0 {
            (passed_tests as f64 / total_tests as f64) * 100.0
        } else {
            0.0
        };
        
        TestReport {
            total_tests,
            passed_tests,
            failed_tests,
            success_rate,
            tolerance: self.tolerance,
            results: self.results.clone(),
        }
    }
    
    fn print_summary(&self) {
        println!("\n{}", "=".repeat(80));
        println!("üìã TEST REPORT SUMMARY");
        println!("{}", "=".repeat(80));
        
        let report = self.generate_report();
        
        println!("Total Tests: {}", report.total_tests);
        println!("Passed: {} ‚úÖ", report.passed_tests);
        println!("Failed: {} ‚ùå", report.failed_tests);
        println!("Success Rate: {:.1}%", report.success_rate);
        
        // Group by phase
        let mut phases: HashMap<u8, Vec<&TestResult>> = HashMap::new();
        for result in &self.results {
            phases.entry(result.phase).or_insert_with(Vec::new).push(result);
        }
        
        println!("\nüìä Results by Phase:");
        for phase in [2, 3, 4, 5] {
            if let Some(results) = phases.get(&phase) {
                let passed = results.iter().filter(|r| r.passed).count();
                let total = results.len();
                println!("  Phase {}: {}/{} passed ({:.1}%)", 
                        phase, passed, total, (passed as f64 / total as f64) * 100.0);
            }
        }
        
        // Show failed tests
        let failed_results: Vec<_> = self.results.iter().filter(|r| !r.passed).collect();
        if !failed_results.is_empty() {
            println!("\n‚ùå Failed Tests:");
            for result in failed_results {
                println!("  {} ({}): {}", 
                        result.function_name, 
                        result.category,
                        result.error_message.as_ref().unwrap_or(&"Unknown error".to_string()));
            }
        }
        
        // Show accuracy statistics for passed tests
        let passed_results: Vec<_> = self.results.iter()
            .filter(|r| r.passed && r.max_error.is_finite())
            .collect();
        
        if !passed_results.is_empty() {
            let max_errors: Vec<f64> = passed_results.iter().map(|r| r.max_error).collect();
            let mean_errors: Vec<f64> = passed_results.iter().map(|r| r.mean_error).collect();
            
            let min_max_error = max_errors.iter().fold(f64::INFINITY, |a, &b| a.min(b));
            let max_max_error = max_errors.iter().fold(0.0f64, |a, &b| a.max(b));
            let avg_max_error = max_errors.iter().sum::<f64>() / max_errors.len() as f64;
            let avg_mean_error = mean_errors.iter().sum::<f64>() / mean_errors.len() as f64;
            
            println!("\nüìà Accuracy Statistics (for passed tests):");
            println!("  Max Error Range: {:.2e} - {:.2e}", min_max_error, max_max_error);
            println!("  Average Max Error: {:.2e}", avg_max_error);
            println!("  Average Mean Error: {:.2e}", avg_mean_error);
        }
        
        // Save detailed results
        if let Err(e) = self.save_results(&report) {
            println!("‚ö†Ô∏è  Failed to save results: {}", e);
        } else {
            println!("\nüíæ Detailed results saved to test/rust_test_results.json");
        }
    }
    
    fn save_results(&self, report: &TestReport) -> Result<(), Box<dyn std::error::Error>> {
        let json = serde_json::to_string_pretty(report)?;
        fs::write("test/rust_test_results.json", json)?;
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Check if reference data exists
    if !std::path::Path::new("test/talib_reference_data.json").exists() {
        eprintln!("‚ùå Reference data not found!");
        eprintln!("   Please run: conda activate talib-env && python test/simple_comparison.py");
        std::process::exit(1);
    }
    
    let tolerance = 1e-8; // Very strict tolerance for 100% compatibility
    let mut comparison = TAComparison::new(tolerance)?;
    
    comparison.run_all_tests();
    comparison.print_summary();
    
    let report = comparison.generate_report();
    
    if report.passed_tests == report.total_tests {
        println!("\nüéâ All tests passed! TA-Rust is 100% compatible with TA-Lib!");
        Ok(())
    } else {
        println!("\n‚ö†Ô∏è  Some tests failed. Please review the results above.");
        std::process::exit(1);
    }
}
